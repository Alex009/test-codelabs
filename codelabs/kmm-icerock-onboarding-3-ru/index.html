
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>IceRock KMM onboarding #3 - реализация фичи авторизации</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="kmm-icerock-onboarding-3-ru"
                  title="IceRock KMM onboarding #3 - реализация фичи авторизации"
                  environment="web"
                  feedback-link="https://github.com/icerockdev/kmp-codelabs/issues">
    
      <google-codelab-step label="Пишем ViewModel" duration="20">
        <p>Теперь перейдем к написанию общей логики нашей фичи. Предположим нам нужно написать типичную фичу авторизации. Экран в таком случае у нас будет не сложный: два поля ввода, для логина и пароля, и кнопка логина. Также нам понадобится лоадер, который мы будем показывать при отправлении запроса на сервер и сообщение об ошибке, на случай если что-то пойдет не так.</p>
<h2 is-upgraded>Расположение ViewModel</h2>
<p>Так как ViewModel реализует общую логику приложения, она находится в общем коде приложения. Для каждой фичи в mpp-library создается отдельный модуль, значит наша ViewModel авторизации будет находится в своем отдельном модуле feature/auth</p>
<p>В новом проекте уже можно увидеть заготовку для нашей ViewModel авторизации</p>
<pre><code language="language-kotlin" class="language-kotlin">class AuthViewModel(
        override val eventsDispatcher: EventsDispatcher&lt;EventsListener&gt;,
) : ViewModel(), EventsDispatcherOwner&lt;AuthViewModel.EventsListener&gt; {

    interface EventsListener
}
</code></pre>
<p>Что такое eventsDispatcher? Это инструмент который служит для связи ViewModel и нативного экрана, если в ViewModel произошло событие, которое требует отображения на экране, либо некоторой нативной обработки мы уведомляем об этом нативную часть через eventsDispatcher. Для примера такими событиями могут быть: Показ диалога или переход на другой экран</p>
<p>Все что нам осталось это написать саму логику авторизации :)</p>
<h2 is-upgraded>Пишем логику для AuthViewModel</h2>
<p>Начнем с полей ввода: нам нужно две мутабельные лайвдаты для ввода логина и пароля</p>
<pre><code language="language-kotlin" class="language-kotlin">val loginField: MutableLiveData&lt;String&gt; = MutableLiveData&lt;String&gt;(&#34;&#34;)
val passwordField: MutableLiveData&lt;String&gt; = MutableLiveData&lt;String&gt;(&#34;&#34;)
</code></pre>
<p>Для этих полей ввода нам также потребуется валидация, ее мы пробросим через конструктор ViewModel, так как она может переиспользоваться на разных экранах. Для отображения ошибки валидации так-же создадим две лайв даты.</p>
<pre><code language="language-kotlin" class="language-kotlin">class AuthViewModel(
        override val eventsDispatcher: EventsDispatcher&lt;EventsListener&gt;,
        private val loginValidation: (String) -&gt; StringDesc?,
        private val passwordValidation: (String) -&gt; StringDesc?
) : ViewModel(), EventsDispatcherOwner&lt;AuthViewModel.EventsListener&gt; {

    val loginField: MutableLiveData&lt;String&gt; = MutableLiveData&lt;String&gt;(&#34;&#34;)
    val passwordField: MutableLiveData&lt;String&gt; = MutableLiveData&lt;String&gt;(&#34;&#34;)

    val loginValidationError: LiveData&lt;StringDesc?&gt; = loginField.map { login -&gt;
        loginValidation(login)
    }
    val passwordValidationError: LiveData&lt;StringDesc?&gt; = passwordField.map { password -&gt;
        passwordValidation(password)
    }

    interface EventsListener
}
</code></pre>
<p>Для удобства имеет смысл выделять все валидаторы в отдельный класс Validation</p>
<pre><code language="language-kotlin" class="language-kotlin">class AuthViewModel(
        override val eventsDispatcher: EventsDispatcher&lt;EventsListener&gt;,
        private val validation: Validation
) : ViewModel(), EventsDispatcherOwner&lt;AuthViewModel.EventsListener&gt; {

    ...

    val loginValidationError: LiveData&lt;StringDesc?&gt; = loginField.map { login -&gt;
        validation.validateLogin(login)
    }
    val passwordValidationError: LiveData&lt;StringDesc?&gt; = passwordField.map { password -&gt;
        validation.validatePassword(password)
    }
</code></pre>
<p>После того как пользователдь ввел свои логин и пароль, нам потребуется обработать нажатие кнопки логина. Для этого напишем функцию onLoginTap. При нажатии кнопки логина, мы должны отправить на сервер запрос с необходимыми данными.</p>
<p>Но в перую очередь нам нужно показать пользователю прогресс бар чтобы он не заскучал в ожидании ответа. Добавим приватную MutableLiveData для флага показа лоадера, и публичную LiveData которую сможет получить натив.</p>
<p>Также добавим лайвдату isButtonEnabled в котрой будет отображен флаг, что кнопка логина доступна к нажатию. Кнопка доступна если все поля корректны и нет активного запроса</p>
<pre><code language="language-kotlin" class="language-kotlin">val _isLoading = MutableLiveData&lt;Boolean&gt;(false)
val isLoading: LiveData&lt;Boolean&gt; = _isLoading.readOnly()

val isButtonEnabled: LiveData&lt;Boolean&gt; = listOf(
        loginValidationError.map { it == null },
        passwordValidationError.map { it == null },
        isLoading.map { it.not() }
).all(true)
</code></pre>
<p>При нажатии кнопки запустим короутину и установим флаг загрузки true</p>
<pre><code language="language-kotlin" class="language-kotlin">fun onLoginTap() {
    viewModelScope.launch {
        _isLoading.value = true
    }
}
</code></pre>
<p>Далее нам требуется отправить запрос на сервер, этим занимается не сама ViewModel а связанный с эти функционалом репозиторий. Котороый нам нужно пробросить в ViewModel через параметры конструктора</p>
<pre><code language="language-kotlin" class="language-kotlin">private val repository: AuthRepository
</code></pre>
<p>Сам вызов suspend функкции репозитория нам нужно обернуть в try-catch, так как нам может вернуться Exception. Например если пользователь ввел неверный логин/пароль, у пользователя пропал интернет или если сервер просто решил отдохнуть.</p>
<p>Для отображения произошедшей ошибки нам и пригодится eventsDispatcher. Добавим в EventsListener нашей ViewModel обработку нового события showError</p>
<pre><code language="language-kotlin" class="language-kotlin">interface EventsListener {
    fun showError(error: StringDesc)
}
</code></pre>
<p>Также нам потребуется мапер, который сможет из полученого исключения сделать красивое сообщение об ошибке, добавим его через конструктор нашей ViewModel</p>
<pre><code language="language-kotlin" class="language-kotlin">    private val errorMapper: (Exception) -&gt; StringDesc
</code></pre>
<p>Наконец обработаем ошибку и не забудем убрать прогресс бар не зависимо от того какой результат мы получили от репозитория</p>
<pre><code language="language-kotlin" class="language-kotlin">try {
    repository.login(loginField.value, passwordField.value)
} catch (exception: Exception) {
    eventsDispatcher.dispatchEvent { showError(errorMapper(exception)) }
} finally {
    _isLoading.value = false
}
</code></pre>
<p>Все что осталось это добавить переход на следующий экран при успешном логине. Для этого добавим обработчик события перехода на main экран в EventsListener</p>
<pre><code language="language-kotlin" class="language-kotlin">interface EventsListener {
    fun showError(error: StringDesc)
    fun routeToMain()
}
</code></pre>
<p>И вызов этого события через eventsDispatcher в блоке try</p>
<pre><code language="language-kotlin" class="language-kotlin">    try {
    repository.login(loginField.value, passwordField.value)
    eventsDispatcher.dispatchEvent { routeToMain() }
}
</code></pre>
<p>На этом наша AuthViewModel фактически готова к использованию. Хотя кое-что в ней еще можно улучшить</p>
<h2 is-upgraded>Принцип связи общей и нативной частей</h2>
<p>В наших проектах используется следующий принцип:</p>
<ul>
<li>Вся общая логика разбита на фичи и находится в mpp-library/feature</li>
<li>Нативная часть андроида приложения находится в app, внутри не бьется нв модули но фичи разбиты по разным пакетам, аналогично разбиению в mpp-library</li>
<li>Нативная часть ios приложения находится в ios-app</li>
<li>Важную часть в связи нативного и общего кода играет SharedFactory, она расположена в mpp-library/src/commonMain и содержит в себе фабрики отдельных фичей, репозитории</li>
<li>Реализаций фабрик фичей и репозиториев необходимых для их работы также расположены в mpp-library/src/commonMain, каждая фабрика фичи умеет создавать все необходимые ViewModel для своей фичи</li>
</ul>
<p>На андроид проекте мы помещаем SharedFactory в AppComponent</p>
<pre><code language="language-kotlin" class="language-kotlin">object AppComponent {
    lateinit var factory: SharedFactory
}
</code></pre>
<p>и инициализируем в методе onCreate нашей Application, после этого обращаемся к ней тогда, когда нам нужно создать какую-либо ViewModel</p>
<h2 is-upgraded>Создание нативного экрана авторизации</h2>
<p>Пришло время написать нативную реализацию экрана.</p>
<p>Сам экран представляет из себя фрагмент, который мы прибиндим к нашей AuthViewModel, для верстки нам понадобится два поля ввода и сообщения об ошибках под ними</p>
<pre><code language="language-xml" class="language-xml">&lt;com.google.android.material.textfield.TextInputEditText
        android:id=&#34;@+id/login&#34;
        android:layout_width=&#34;0dp&#34;
        android:layout_height=&#34;wrap_content&#34;
        app:layout_constraintEnd_toEndOf=&#34;parent&#34;
        android:layout_marginHorizontal=&#34;16dp&#34;
        android:layout_marginTop=&#34;160dp&#34;
        app:layout_constraintStart_toStartOf=&#34;parent&#34;
        app:layout_constraintTop_toTopOf=&#34;parent&#34;/&gt;

&lt;androidx.appcompat.widget.AppCompatTextView
android:id=&#34;@+id/loginValidation&#34;
android:layout_width=&#34;0dp&#34;
android:layout_height=&#34;wrap_content&#34;
android:textAppearance=&#34;?textAppearanceBody2&#34;
android:textColor=&#34;?colorAccent&#34;
app:layout_constraintTop_toBottomOf=&#34;@id/login&#34;
app:layout_constraintStart_toStartOf=&#34;@id/login&#34;
app:layout_constraintEnd_toEndOf=&#34;@id/login&#34;/&gt;

&lt;com.google.android.material.textfield.TextInputEditText
android:id=&#34;@+id/password&#34;
android:layout_marginHorizontal=&#34;16dp&#34;
android:layout_width=&#34;0dp&#34;
android:layout_height=&#34;wrap_content&#34;
android:layout_marginTop=&#34;16dp&#34;
app:layout_constraintEnd_toEndOf=&#34;parent&#34;
app:layout_constraintStart_toStartOf=&#34;parent&#34;
app:layout_constraintTop_toBottomOf=&#34;@id/login&#34;/&gt;

&lt;androidx.appcompat.widget.AppCompatTextView
android:id=&#34;@+id/passwordValidation&#34;
android:layout_width=&#34;0dp&#34;
android:layout_height=&#34;wrap_content&#34;
android:textAppearance=&#34;?textAppearanceBody2&#34;
android:textColor=&#34;?colorAccent&#34;
app:layout_constraintTop_toBottomOf=&#34;@id/password&#34;
app:layout_constraintStart_toStartOf=&#34;@id/password&#34;
app:layout_constraintEnd_toEndOf=&#34;@id/password&#34;/&gt;
</code></pre>
<p>кнопка для логина</p>
<pre><code language="language-xml" class="language-xml">&lt;androidx.appcompat.widget.AppCompatButton
        android:id=&#34;@+id/button_login&#34;
        android:layout_width=&#34;match_parent&#34;
        android:layout_height=&#34;wrap_content&#34;
        android:layout_margin=&#34;40dp&#34;
        android:text=&#34;@string/auth_button_enter&#34;
        app:layout_constraintBottom_toBottomOf=&#34;parent&#34;
        app:layout_constraintEnd_toEndOf=&#34;parent&#34;
        app:layout_constraintStart_toStartOf=&#34;parent&#34;
        tools:text=&#34;Войти&#34;/&gt;
</code></pre>
<p>и прогресс бар на время загрузки</p>
<pre><code language="language-xml" class="language-xml">&lt;ProgressBar
        android:id=&#34;@+id/loading&#34;
        android:layout_width=&#34;wrap_content&#34;
        android:layout_height=&#34;wrap_content&#34;
        app:layout_constraintBottom_toBottomOf=&#34;parent&#34;
        app:layout_constraintEnd_toEndOf=&#34;parent&#34;
        app:layout_constraintStart_toStartOf=&#34;parent&#34;
        app:layout_constraintTop_toTopOf=&#34;parent&#34;/&gt;
</code></pre>
<p>Теперь перейдем к созданию самого фрагмента</p>
<pre><code language="language-kotlin" class="language-kotlin">class AuthFragment :
        MvvmEventsFragment&lt;FragmentAuthBinding, AuthViewModel, AuthViewModel.EventsListener&gt;(),
        AuthViewModel.EventsListener {
</code></pre>
<p>класс AuthFragment наследуется от MvvmEventsFragment из dev.icerock.moko:mvvm-viewbinding в дженерике мы указываем ему сгенерированный класс верстки, класс вьюмодели, и класс лстенера для eventDispatcher MvvmEventsFragment сам подпишется на eventDispatcher вьюмодели, в отличие от MvvmFragment При наследовании от MvvmEventsFragment нам нужно реализовать</p>
<ul>
<li>viewModelClass указать класс используемой viewModel</li>
<li>viewBindingInflate создать экземпляр сгенерированного из верстки класса FragmentAuthBinding</li>
<li>viewModelFactory реализовать фэктори для создания необходимой ViewModel</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">    override val viewModelClass: Class&lt;AuthViewModel&gt; = AuthViewModel::class.java

override fun viewBindingInflate(
        inflater: LayoutInflater,
        container: ViewGroup?
): FragmentAuthBinding {
    return FragmentAuthBinding.inflate(layoutInflater, container, false)
}

override fun viewModelFactory(): ViewModelProvider.Factory = ViewModelFactory {
    AppComponent.factory.authFactory.createAuthViewModel(eventsDispatcherOnMain())
}
</code></pre>
<p>Помимо этого нужно реализовать функции интерфейса AuthViewModel.EventsListener от которого мы отнаследовались, что-бы фрагмент мог реагировать на события которые будет отправлять viewModel Так как никаких других фрагментов для навигации нет просто покажем тост который покажет нам, что ивент получен</p>
<pre><code language="language-kotlin" class="language-kotlin">    override fun showError(error: StringDesc) {
    context?.let { context -&gt;
        AlertDialog.Builder(context)
                .setMessage(error.toString(context))
                .setCancelable(true)
                .show()
    }
}

override fun routeToMain() {
    Toast.makeText(requireContext(), &#34;Успех!&#34;, Toast.LENGTH_SHORT).show()
}
</code></pre>
<h2 is-upgraded>Байндинг фрагмента к ViewModel</h2>
<p>Теперь нам нужно связать наши поля и кнопки с AuthViewModel. Для этого в методе onViewCreated мы можем использовать уже заранее написаные методы bind</p>
<p>Привязываем мутабл лайвдаты логина и пароля к view</p>
<pre><code language="language-kotlin" class="language-kotlin">    viewModel.loginField.bindTwoWayToEditTextText(viewLifecycleOwner, binding.login)
viewModel.passwordField.bindTwoWayToEditTextText(viewLifecycleOwner, binding.login)
</code></pre>
<p>Привязываем лайвдаты ошибок к соответствующим TextView</p>
<pre><code language="language-kotlin" class="language-kotlin">    val context = requireContext()
viewModel.loginValidationError.bind(viewLifecycleOwner) {
    binding.loginValidation.text = it?.toString(context)
}
viewModel.passwordValidationError.bind(viewLifecycleOwner) {
    binding.passwordValidation.text = it?.toString(context)
}
</code></pre>
<p>и осталось привязать видимость прогресс бара</p>
<pre><code language="language-kotlin" class="language-kotlin">    viewModel.isLoading.bindToViewVisibleOrGone(viewLifecycleOwner, binding.loading)
viewModel.isButtonEnabled.bindToViewEnabled(viewLifecycleOwner, binding.buttonLogin)
</code></pre>
<p>Теперь наш фрагмент может отображать данные из viewModel, и передавать ей то что введено в поля ввода. Осталось добавить листенер для кнопки логина</p>
<pre><code language="language-kotlin" class="language-kotlin">    binding.buttonLogin.setOnClickListener {
    viewModel.onLoginTap()
}
</code></pre>
<p>На iOS также SharedFactory помещается в AppComponent. Для этого в классе AppComponent есть статическое поле factory:</p>
<pre><code language="language-swift" class="language-swift">class AppComponent {
    static var factory: SharedFactory!
}
</code></pre>
<p>В AppDelegate в методе didFinishLaunchingWithOptions создаём SharedFactory с передачей необходимых параметров и кладём её в поле factory у AppComponent.</p>
<pre><code language="language-swift" class="language-swift">  AppComponent.factory = SharedFactory(
      settings: AppleSettings(delegate: UserDefaults.standard),
      antilog: DebugAntilog(defaultTag: &#34;MPP&#34;),
      baseUrl: &#34;https://newsapi.org/v2/&#34;
  )
</code></pre>
<h2 is-upgraded>Навигация</h2>
<h3 is-upgraded>Android</h3>
<p>Для навигации в андроид приложении мы используем NavController.</p>
<p>Есть одна RootActivity. А все экраны приложения представляют собой фрагменты, навигация между которыми реализована через NavController</p>
<p>Для реализации в gradle андроид app нужно добавить</p>
<pre><code>    implementation(Deps.Libs.Android.navigatonFragment)
    implementation(Deps.Libs.Android.navigatonUI)
</code></pre>
<p>Реализуем простую RootActivity</p>
<pre><code language="language-kotlin" class="language-kotlin">class RootActivity : AppCompatActivity() {

    private lateinit var navController: NavController
    private lateinit var binding: ActivityRootBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityRootBinding.inflate(LayoutInflater.from(this))
        setContentView(binding.root)
        initNavController()
    }

    private fun initNavController() {
        val host =
                supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment
        navController = host.navController
    }
}

</code></pre>
<p>и простую верстку в которой помещаем NavHostFragment в контейнер экрана</p>
<pre><code language="language-xml" class="language-xml">&lt;FrameLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
             xmlns:app=&#34;http://schemas.android.com/apk/res-auto&#34;
             android:id=&#34;@+id/root_container&#34;
             android:layout_width=&#34;match_parent&#34;
             android:layout_height=&#34;match_parent&#34;&gt;

    &lt;fragment
            android:id=&#34;@+id/nav_host_fragment&#34;
            android:name=&#34;androidx.navigation.fragment.NavHostFragment&#34;
            android:layout_width=&#34;match_parent&#34;
            android:layout_height=&#34;match_parent&#34;
            app:defaultNavHost=&#34;true&#34;
            app:navGraph=&#34;@navigation/root_navigation&#34;/&gt;
&lt;/FrameLayout&gt;
</code></pre>
<p>После чего нам остается описать навигацию в root_navigation.xml, в данный момент она будет состоять из одного фрагмента, который и является стартовым</p>
<pre><code language="language-xml" class="language-xml">&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
&lt;navigation xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
            xmlns:app=&#34;http://schemas.android.com/apk/res-auto&#34;
            android:id=&#34;@+id/root_navigation&#34;
            app:startDestination=&#34;@id/auth&#34;&gt;

    &lt;fragment
            android:id=&#34;@+id/auth&#34;
            android:name=&#34;org.example.app.features.auth.AuthFragment&#34;/&gt;
&lt;/navigation&gt;
</code></pre>
<p>Далее для переходов между фрагментами будем использовать сгенерированый класс Directions и navController фрагмента. Например</p>
<pre><code language="language-kotlin" class="language-kotlin">   val dir = AuthFragmentDirections.actionAuthToRequestResetPassword()
navController?.navigate(dir)
</code></pre>
<h3 is-upgraded>iOS</h3>
<p>В основе навигации лежат координаторы. Каждый координатор покрывает логически связанный блок функционала, который чаще всего состоит из нескольких экранов. При этом между собой они независимы и отвечают только за цепочку переходов только внутри себя. Также имеют возможность получать настройку действия, которое должно быть выполнено после завершения блока ответственности координатора.</p>
<p>Например.</p>
<p>Предположим, что у нас есть приложение, в котором имеется авторизация, просмотр списка новостей, с возможностью перехода к детальному виду каждой новости, а со списка новостей можно попасть в раздел настроек для конфигурации отображения новостей. Это разобьётся на 4 координатора:</p>
<ol type="1">
<li>AppCoordinator</li>
</ol>
<ul>
<li>Стартовый координатор.</li>
<li>Всегда является первой входной точкой, определяет, куда должен выполниться дальнейший переход при запуске приложения</li>
<li>Если юзер не авторизован - запустит координатор авторизации и в качестве completionHandler-а укажет ему переход на новости в случае успешной авторизации</li>
<li>Если юзер уже авторизован - запустит координатор просмотра новостей</li>
</ul>
<ol type="1">
<li>AuthCoordinator</li>
</ol>
<ul>
<li>Запустит процесс авторизации</li>
<li>Будет совершать переходы по всем требуемым шагам - например ввод логина/пароля, смс-кода, установки никнейма и т.п.</li>
<li>По итогу успешной авторизации вызовет переданный ему на вход completionHandler.</li>
</ul>
<ol type="1">
<li>NewsCoordinator</li>
</ol>
<ul>
<li>Отвечает за показ списка новостей</li>
<li>Реализовывает переход в детали конкретной новости внутри этого же координатора</li>
<li>При переходе в настройки создаёт координатор настроек, с качестве completionHandler-а может передать ему логику обновления своего списка новостей. Если в настройках изменились параметры</li>
<li>обновляет список</li>
</ul>
<ol type="1">
<li>SettingsCoordinator</li>
</ol>
<ul>
<li>Отвечает за работу с экраном настроек</li>
<li>При завершении работы и применении настроек вызывает completion, чтобы новости обновились</li>
</ul>
<p>Именно координаторы реализуют интерфейс EventListener-ов вьюмоделей, о которых будет чуть ниже. Так как вызов переходов завязан на бизнес-логику приложения, то инициатором этих переходов являются именно вьюмодели. Поэтому координаторы выполняют связующую роль между тем, что происходит в логике приложений и тем, как это должно отражаться пользователю.</p>
<p>Чтобы работать с координаторами было проще, используется базовый класс, от которого наследуются остальные. Он называется BaseCoordinator и лежит в директории ios-app/src/Common/Coordinator. Требование к координатору - это реализация протокола Coordinator, который лежит рядом в той же директории:</p>
<pre><code language="language-swift" class="language-swift">protocol Coordinator: class {
    var completionHandler: (()-&gt;())? { get }
    func start()
    func clear()
}
</code></pre>
<p>completionHandler - коллбэк, который вызывается при завершении работы координатора (например закончили флоу авторизации) start - метод старта координатора. Внутри него координатор должен определить, какой экран у него должен быть стартовым, создать его и отобразить clear - метод очистки координатора. В нём необходимо очистить дочерние координаторы.</p>
<p>Всё это есть в базовом координаторе. Даже больше. Пройдёмся по основным важным моментам BaseCoordinator-а.</p>
<p>Для инициализации ему требуется передать UIWindow и SharedFactory. UIWindow требуется для отображения контроллеров, диалогов, а SharedFactory позволит создавать вьюмодели для контроллеров.</p>
<p>В поле childCoordinators хранится массив дочерних координаторов. Они нужны для того, чтобы иметь возможность при завершении работы координатора корректно очистить их и избежать утечек памяти.</p>
<p>Также имеются два коллбэка - completionHandler и clearHandler. Первый нужен для того, чтобы указать необходимую дополнительную логику, которая должна выполниться, когда координатор сообщит о том, что он выполнил свою часть логики. А второй необходим для обработки события о том, что координатор очищен.</p>
<p>Чтобы избежать ошибок в построении связей и переходах в базовом координаторе заведены следующие публичные методы:</p>
<ul>
<li>addDependency - этот метод используется для того, чтобы добавить текущему координатору в зависимость новый координатор. Он проверит есть ли уже координатор такого типа в зависимостях, а при отсутствии - выполнит добавление и подстрахует с добавлением вызова удаления зависимости.</li>
<li>beginInNewNavigation - принимает UIViewController, создаёт с ним новый UINavigationController и запускает новую цепочку навигации, устанавливая этот контроллер навигации как рутовый в UIWindow.</li>
<li>beginInExistNavigation - принимает UIViewController, запоминает в качестве предыдущего контроллера тот, который сейчас последний в текущем UINavigationController. Это нужно для того, чтобы при очистке координатора выполнить переход к тому контроллеру, с которого мы пришли на этот координатор.</li>
<li>currentViewController - возвращает текущий контроллер координатора</li>
</ul>
<h2 is-upgraded>Создание нативного экрана авторизации</h2>
<h3 is-upgraded>Android</h3>
<p>Пришло время написать нативную реализацию экрана.</p>
<p>Сам экран представляет из себя фрагмент, который мы прибиндим к нашей AuthViewModel, для верстки нам понадобится два поля ввода и сообщения об шибках под ними</p>
<p>кнопка для логина</p>
<p>и прогресс бар на время загрузки</p>
<p>Теперь, когда у нас есть готовая верстка перейдем к созданию самого фрагмента</p>
<pre><code language="language-kotlin" class="language-kotlin">class AuthFragment :
        MvvmEventsFragment&lt;FragmentAuthBinding, AuthViewModel, AuthViewModel.EventsListener&gt;(),
        AuthViewModel.EventsListener {
</code></pre>
<p>класс AuthFragment наследуется от MvvmEventsFragment из dev.icerock.moko:mvvm-viewbinding в дженерике мы указываем ему сгенерированный класс верстки, класс вьюмодели, и класс лстенера для eventDispatcher MvvmEventsFragment сам подпишется на eventDispatcher вьюмодели, в отличие от MvvmFragment При наследовании от MvvmEventsFragment нам нужно реализовать</p>
<ul>
<li>viewModelClass указать класс используемой viewModel</li>
<li>viewBindingInflate создать экземпляр сгенерированного из верстки класса FragmentAuthBinding</li>
<li>viewModelFactory реализовать фэктори для создания необходимой ViewModel</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">    override val viewModelClass: Class&lt;AuthViewModel&gt; = AuthViewModel::class.java

override fun viewBindingInflate(
        inflater: LayoutInflater,
        container: ViewGroup?
): FragmentAuthBinding {
    return FragmentAuthBinding.inflate(layoutInflater, container, false)
}

override fun viewModelFactory(): ViewModelProvider.Factory = ViewModelFactory {
    AppComponent.factory.authFactory.createAuthViewModel(eventsDispatcherOnMain())
}
</code></pre>
<h3 is-upgraded>iOS</h3>
<p>Как правило фичи в нативном проекте соответствуют аналогичным фичам в мультиплатформенном проекте. Мы начнём с простого</p>
<ul>
<li>с авторизации. Если открыть в AndroidStudio проект и зайти в папку mpp-library, то мы увидим в ней папку features - это и есть наши фичи. В ней уже даже есть auth. Сделаем для неё нативную реализацию.</li>
</ul>
<p>Сначала наметим структуру папок в нашем проекте. Внутри src создадим папку Features, а в ней - Auth. Для авторизации нам понадобится контроллер и координатор. Чтобы всё не смешивалось в кучу (а в боевых проектах в фиче сильно больше файлов будет) сразу научимся группировать по папкам содержимое фичи. Заведём директории под контроллеры, координаторы и сами классы. Получится следующая структура:</p>
<p>Вёрстку мы ведём через xib-файлы. Обработчики действий и связи настраиваются через IBActions и IBOutlets. Кастомизация UI-элементов стилями конкретного проекта уже происходит кодом. Здесь мы не будем уходить глубоко в кастомизацию, поэтому контроллер у нас будет довольно простой - лейбл, пара полей для ввода логина и пароля и кнопка входа.</p>
<p>На вкус и цвет фломастеры бывают разные, можешь отверстать экран по-своему. Основные требования - Label-заголовок, два UITextField и одна кнопка UIButton. Что-то типа такого:</p>
<p>И класс у неё также пока очень простой:</p>
<pre><code language="language-swift" class="language-swift">import UIKit

class AuthViewController: UIViewController {

    // MARK:** - Outlets**

    @IBOutlet private var welcomeLabel: UILabel!
    @IBOutlet private var loginTextField: UITextField!
    @IBOutlet private var passwordTextField: UITextField!
    @IBOutlet private var loginButton: UIButton!

    // MARK:** - Actions**

    @IBAction func onLoginButtonAction(_ sender: UIButton) {
        // On button Action
    }
}

Далее создадим координатор:

class AuthCoordinator: BaseCoordinator {

    // MARK:** - Overrides**

    override func start() {
        let vc = AuthViewController()
        self.window.rootViewController = vc
    }
}
</code></pre>
<p>Он также несложный. Состоит пока из одного метода start, который помещает на window наш созданный AuthViewController.</p>
<p>И чтобы это всё работало изменяем координатор приложения. Теперь нам там нужно убрать тот тестовый зелёный экран и запустить флоу координатора авторизации:</p>
<pre><code language="language-swift" class="language-swift">class AppCoordinator: BaseCoordinator {

    // MARK:** - Overrides**
    override func start() {
        routeToAuth()
    }

    private func routeToAuth() {

        // 1. Создаём координатор авторизации
        let authCoordinator = AuthCoordinator(window: self.window)

        // 2. Обязательно указываем в completionHandler удаление зависимости.
        // Также добавляем сразу заготовку под будущий переход к новостям при успешной авторизации

        authCoordinator.completionHandler = { [weak self] in
            self?.removeDependency(authCoordinator)
            self?.routeToNewsList()
        }

        // 3. Добавляем новый координатор в зависимость к текущему
        addDependency(authCoordinator)

        // 4. Вызываем у него старт
        authCoordinator.start()
    }

    private func routeToNewsList() {
        // Здесь будет переход к новостям
    }
}

</code></pre>
<p>Собираем, запускаем и видим уже не тот недохромакей, а контроллер авторизации, который только что сверстали. Комментариями к коду подписаны основные шаги в создании нового координатора. Важным моментом является удаление зависимости в completion-блоке создаваемого координатора, чтобы не плодились утечки памяти.</p>
<p>Также полезно будет указать сразу заглушку для метода перехода к новостям. Пусть он пока и пустой, зато сразу получаем более общую картину, где какие вызовы будут в будущем.</p>
<p>Окей. Мы создали контроллер, создали координатор. Даже перешли на экран авторизации. Но как будет реализовываться логика? Где брать вьюмодель? Как она узнает, что юзер что-то ввёл? Как координатор поймёт, что ему нужно вызывать completion и переходить к новостям, ведь контроллер, который мы создали, даже не знает о том, что какой-то там координатор существует?</p>
<p>Чтобы понять, как это работает перейдём к созданию вьюмодели и передаче её контроллеру.</p>
<h2 is-upgraded>Реализация логики и передача событий и команд от общей части к нативной</h2>
<p>// Дополняем EventListener для VM авторизации, в ней роут на новости и showError</p>
<p>ПОКАЗАТЬ ЧТО СБОРКА ЛОМАЕТСЯ, объяснить, как влияют правки общие на соседнюю платформу. Замокать без репозитория на уровне VM проверку логина/пароля.</p>
<h2 is-upgraded>Локализация и ресурсы</h2>
<p>// Рассказать про моко-ресурсы, завести табличку, добавить строк, добавить интерфейс строк в VM, пробросить при реализации, изменить текста ошибок на StringDesc локализованный.</p>
<h2 is-upgraded>Сохранение в локальное хранилище.</h2>
<p>// Добавить логику запоминания токена в локальном хранилище. Показать, как с сеттингсами работать.</p>
<h2 is-upgraded>Построение экранов</h2>
<p>// Раздел для описания разных подходов к вёрстке экранов</p>
<h3 is-upgraded>Нативная вёрстка</h3>
<p>// Сослаться на авторизацию, объяснить про вёрстку на чистом нативе с биндингами</p>
<h2 is-upgraded>Обработка ошибок</h2>
<p>// моко-еррорс</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
