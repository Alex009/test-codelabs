
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>IceRock KMM onboarding #2 - знакомство с устройством проекта</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="kmm-icerock-onboarding-2-ru"
                  title="IceRock KMM onboarding #2 - знакомство с устройством проекта"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Построение навигации в iOS приложении" duration="20">
        <p>Прежде чем идти дальше немного остановимся на том, как построена навигация в iOS приложение и какие подходы при работе с ней мы используем.</p>
<p>В основе навигации лежат координаторы. Каждый координатор покрывает логически связанный блок функционала, который чаще всего состоит из нескольких экранов. При этом между собой они независимы и отвечают только за цепочку переходов только внутри себя. Также имеют возможность получать настройку действия, которое должно быть выполнено после завершения блока ответственности координатора.</p>
<p>Например.</p>
<p>Предположим, что у нас есть приложение, в котором имеется авторизация, просмотр списка новостей, с возможностью перехода к детальному виду каждой новости, а со списка новостей можно попасть в раздел настроек для конфигурации отображения новостей. Это разобьётся на 4 координатора:</p>
<ol type="1">
<li>AppCoordinator  <ol type="1">
<li>Стартовый координатор. Всегда является первой входной точкой, определяет, куда должен выполниться дальнейший переход при запуске приложения</li>
<li>Если юзер не авторизован - запустит координатор авторизации и в качестве completionHandler-а укажет ему переход на новости в случае успешной авторизации</li>
<li>Если юзер уже авторизован - запустит координатор просмотра новостей</li>
</ol>
</li>
<li>AuthCoordinator  <ol type="1">
<li>Запустит процесс авторизации</li>
<li>Будет совершать переходы по всем требуемым шагам - например ввод логина/пароля, смс-кода, установки никнейма и т.п.</li>
<li>По итогу успешной авторизации вызовет переданный ему на вход completionHandler.</li>
</ol>
</li>
<li>NewsCoordinator  <ol type="1">
<li>Отвечает за показ списка новостей</li>
<li>Реализовывает переход в детали конкретной новости внутри этого же координатора</li>
<li>При переходе в настройки создаёт координатор настроек, с качестве completionHandler-а может передать ему логику обновления своего списка новостей. Если в настройках изменились параметры  <ul>
<li>обновляет список</li>
</ul>
</li>
</ol>
</li>
<li>SettingsCoordinator  <ol type="1">
<li>Отвечает за работу с экраном настроек</li>
<li>При завершении работы и применении настроек вызывает completion, чтобы новости обновились</li>
</ol>
</li>
</ol>
<p>Именно координаторы реализуют интерфейс EventListener-ов вьюмоделей, о которых будет чуть ниже. Так как вызов переходов завязан на бизнес-логику приложения, то инициатором этих переходов являются именно вьюмодели. Поэтому координаторы выполняют связующую роль между тем, что происходит в логике приложений и тем, как это должно отражаться пользователю.</p>
<p>Чтобы работать с координаторами было проще, используется базовый класс, от которого наследуются остальные. Добавим его к нашему проекту.</p>
<p>Создадим в ios-проекте папку src/Coordinators и в ней файлик BaseCoordinator. Для начала докинем туда пару протоколов:</p>
<pre><code language="language-swift" class="language-swift">protocol ChildCoordinable {

    var childCoordinators: [Coordinator] { get set }

    func addDependency(_ coordinator: Coordinator)

    func removeDependency(_ coordinator: Coordinator?)

}
</code></pre>
<p>ChildCoordinable - необходим для корректной работы с зависимостями от дочерних координаторов. Необходимо не забывать добавлять зависимости на новый координаторы, очищать зависимость на конкретный координатор и запоминать список тех координаторов, которые являются дочерними к текущему.</p>
<pre><code language="language-swift" class="language-swift">protocol Coordinator: class {

    var completionHandler: (() -&gt; Void)? { get set }

    

    func start()

}
</code></pre>
<p>Coordinator - сам протокол координатора. По сути он должен иметь ровно две вещи - completionHandler, который вызовется при завершении его логической зоны ответственности. И функцию start. При её вызове он начинает запускать свой флоу таким образом, каким считает нужным.</p>
<p>И далее сам класс базового координатора, который реализует оба этих протокола:</p>
<pre><code language="language-swift" class="language-swift">class BaseCoordinator: NSObject, Coordinator, ChildCoordinable, UINavigationControllerDelegate {

    var childCoordinators: [Coordinator] = []

    var completionHandler: (() -&gt; Void)?

    

    let window: UIWindow

    

    weak var navigationController: UINavigationController?

    

    init(window: UIWindow) {

        self.window = window

    }

    

    func start() {

        

    }

    

    func addDependency(_ coordinator: Coordinator) {

        for element in childCoordinators where element === coordinator {

            return

        }

        childCoordinators.append(coordinator)

    }

    

    func removeDependency(_ coordinator: Coordinator?) {

        guard

            childCoordinators.isEmpty == false,

            let coordinator = coordinator

        else { return }

        

        for (index, element) in childCoordinators.enumerated() where element === coordinator {

            

            childCoordinators.remove(at: index)

            break

            

        }

    }

    

    func currentViewController() -&gt; UIViewController? {

        return self.navigationController?.topViewController?.presentedViewController ?? self.navigationController?.topViewController ?? self.navigationController

    }

    

    func popBack() {

        self.navigationController?.popViewController(animated: true)

    }

}
</code></pre>
<p>Для инициализации необходим только window. Также можно указать NavigationController с предыдущего координатора, для сохранения общей навигации.</p>
<p>Добавление и удаление зависимостей нужны для корректной очистки связей и памяти при построении цепочек координаторов.</p>
<p>Также есть вспомогательные методы, которые позволяют получить текущий контроллер - currentViewController и совершить переход назад - popBack.</p>
<p>От проекта к проекту базовый координатор может изменяться, обеспечивая дополнительные нужды проекта.</p>
<p>Теперь, когда у нас есть базовый координатор, создадим на его основе стартовый координатор приложения. Создаём рядом с AppDelegate файл для него, называем AppCoordinator:</p>
<pre><code language="language-swift" class="language-swift">import Foundation

import UIKit

class AppCoordinator: BaseCoordinator {

    // MARK:** - Overrides**

    override func start() {

        let vc = UIViewController()

        vc.view.backgroundColor = UIColor.green

        self.window.rootViewController = vc

    }

}
</code></pre>
<p>Пусть он пока будет совсем простой, создающий контроллер зелёного цвета и делает его главным экраном window.</p>
<p>Теперь нам надо познакомить AddDelegate с его координатором. Идём в AppDelegate.swift</p>
<p>Добавим ему ссылку на координатор приложения:</p>
<p>private (set) var coordinator: AppCoordinator!</p>
<p>А в didFinishLaunchingWithOptions после создания SharedFactory добавим создание координатора и вызов старта:</p>
<pre><code language="language-swift" class="language-swift">self.coordinator = AppCoordinator(

            window: self.window!

        )

self.coordinator.start()
</code></pre>
<p>Готово. Собираем, запускаем и видим наш зелёный контроллер:</p>
<p>Теперь дальнейшая логика переходов зависит от текущего контроллера и действий юзера на нём. Но зелёным прямоугольником мир не спасёшь и юзера не авторизуешь. Поэтому пора переходить к созданию нашей первой фичи.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
