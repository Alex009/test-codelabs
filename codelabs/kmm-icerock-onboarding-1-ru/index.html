
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>IceRock KMM onboarding #1</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="kmm-icerock-onboarding-1-ru"
                  title="IceRock KMM onboarding #1"
                  environment="web"
                  feedback-link="https://github.com/icerockdev/kmp-codelabs/issues">
    
      <google-codelab-step label="Вводная" duration="5">
        <p>Привет! Если ты это читаешь, значит ты начинаешь погружаться в процессы мультиплатформенной разработки в IceRock.</p>
<p>Мы активно применяем и продвигаем этот подход с 2017-2018 годов. Основная его ценность для нас - это возможность объединения бизнес-логики приложения в одном месте для обеих платформ. Вместо того, чтобы отлаживать и реализовывать логику отдельно для iOS и Android мы пишем общий код, который используют обе платформы. Один и тот же код. Соответственно, баги, связанные с некорректной логикой, не будут плавать с платформы на платформу. И не потребуется отвлекать разных разработчиков - проблемы в логике могут быть исправлены одним человеком, в одном месте и починить сразу и iOS, и Android. Круто же)</p>
<p>При этом взаимодействие с пользователем остаётся 100% нативным. Доступен полный набор всех средств, которые предоставляют нативные SDK. Юзер использует привычные элементы и приложение ведёт себя так, как привыкли пользователи каждой платформы.</p>
<p>Обратная сторона медали - сложности на первых порах, при вхождении в такой подход и метод разработки. Для андроид-разработчиков особо ничего не меняется - они могут использовать всё тот же Kotlin, модульность, Gradle, корутины и прочие незнакомые большинству iOS-ников вещи. А iOS-разработчик, в свою очередь, попадая впервые на мультиплатформенный проект, едет кукухой от того, что в проект подцепляется какой-то мультиплатформенный под-чёрный-ящик, в котором какая-то куча вьюмоделей, реализующих внутри магию с логикой, кругом какие-то диспатчеры, юниты, экран со сложной вёрсткой в контроллере состоит из таблицы и нескольких строчек биндинга,не понятно откуда что берётся и вопросов больше, чем ответов.</p>
<p>На самом же деле всё довольно просто и логично. Сгруппировано, разбито и структурировано. Но вникнуть в эту концепцию придя на уже живущий проект, находящийся в активной разработке сложно из-за большого объёма информации и логики.</p>
<p>Поэтому данный гайд призван помочь пройтись по шагам по основным практически моментам, ежедневно встречающимся в нашей повседневной разработке. В нём ты сможешь по очереди выполнять задания, наращивать функционал тестового проекта и изучать устройство проекта изнутри.</p>
<p>Здесь не будет детального разбора теоретической части, т.к. по ней уже имеется большое количество статей и документации, к которым можно обращаться в процессе. Вставить ссылку на страницу с доками Здесь ты именно закрепляешь на практике теоретические знания из статей. Так что наливай чаёк-кофеёк и поехали)</p>


      </google-codelab-step>
    
      <google-codelab-step label="Подготовительные шаги" duration="5">
        <p>В рамках адаптации ты уже должен был развернуть себе рабочее окружение, поэтому тут не заостряемся на этом. Глянуть детальнее можно здесь: <a href="https://kmm.icerock.dev/pages/2-setup/" target="_blank">https://kmm.icerock.dev/pages/2-setup/</a></p>
<p>Основные два рабочих инструмента - Android Studio и Xcode.</p>
<p>В качестве отправной точки мы будем использовать наш шаблоный проект - <strong>mobile-moko-boilerplate</strong>. Он используется на всех новых проектах для быстрого развёртывания и старта разработки. Там уже подключены все минимально необходимые зависимости, имеется нужная структура папок и базовая настройка проекта. Так что заходим на GitLab в репозиторий <a href="https://gitlab.icerockdev.com/scl/boilerplate/mobile-moko-boilerplate" target="_blank">https://gitlab.icerockdev.com/scl/boilerplate/mobile-moko-boilerplate</a> и делаем форк себе в профиль, клонируем.</p>
<p>Для начала откроем в его Android Studio.</p>
<p>Запускаем студию, File -&gt; Open -&gt; И выбираем папку, в которую склонировали репозиторий. При первом открытии должно появиться следующее:</p>
<p>По-умолчанию студия парсит каталоги и строит отображение как для Android-проекта. Но мы здесь будем работать не только с андроидом, но и с мультиплатформой.</p>
<p>Поэтому переключаем отображение. Для этого слева нажимаем на выпадашку Android и выбираем вместо него Project:</p>
<p>После этого структура папок немного изменится:</p>
<p>Далее соберём iOS проект. Как именно это сделать можно прочитать тут же в Readme открытого проекта. Но чтобы было нагляднее - пройдём эти незамысловатые шаги для ios-проекта.</p>
<p>Сначала ставим поды.</p>
<p>После этого справа разворачиваем панель Gradle. Внутри Tasks/cocoapods находим нужную нам таску(ниже скрин):</p>
<p>syncMultiPlatformLibraryDebugFrameworkIosX64</p>
<p>и запускаем её двойным кликом. Тут придётся немного подождать. А чтобы лучше понять, что сейчас произошло, как эти таски появились и что это за Gradle и слон со стрелкой - идём читать статейку про Gradle для айосников тут:</p>
<p><a href="https://kmm.icerock.dev/pages/4.1.1-kmm-ios-gradle/" target="_blank">https://kmm.icerock.dev/pages/4.1.1-kmm-ios-gradle/</a></p>
<p>После успешного завершения билда необходимо ещё раз выполнить установку подов. И далее можно запускать Xcode и открывать проект, который лежит по пути ios-app/ios-app.xcworkspace</p>
<p>Выбираем любой симулятор, жмём Run - проект собирается и запускается.</p>
<p>И это успех) Мы выкачали и собрали мультиплатформенный проект с нуля. Аналогичным образом происходит работа со всеми другими MPP-проектами в компании. Поэтому когда ты попадёшь на боевой проект, то уже точно будешь знать, как его выкачать из репозитория, собрать и запустить у себя. Наиболее частая причина ошибок на этом шаге - неправильная последовательность действий. Если вдруг что-то пошло не так, то проверь, что ты установил поды, выполнил синк, а после этого снова установил поды.</p>
<p>А мы переходим к следующей части и разберёмся, как работать с этим дальше.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Построение навигации в iOS приложении" duration="20">
        <p>Прежде чем идти дальше немного остановимся на том, как построена навигация в iOS приложение и какие подходы при работе с ней мы используем.</p>
<p>В основе навигации лежат координаторы. Каждый координатор покрывает логически связанный блок функционала, который чаще всего состоит из нескольких экранов. При этом между собой они независимы и отвечают только за цепочку переходов только внутри себя. Также имеют возможность получать настройку действия, которое должно быть выполнено после завершения блока ответственности координатора.</p>
<p>Например.</p>
<p>Предположим, что у нас есть приложение, в котором имеется авторизация, просмотр списка новостей, с возможностью перехода к детальному виду каждой новости, а со списка новостей можно попасть в раздел настроек для конфигурации отображения новостей. Это разобьётся на 4 координатора:</p>
<ol type="1">
<li>AppCoordinator  <ol type="1">
<li>Стартовый координатор. Всегда является первой входной точкой, определяет, куда должен выполниться дальнейший переход при запуске приложения</li>
<li>Если юзер не авторизован - запустит координатор авторизации и в качестве completionHandler-а укажет ему переход на новости в случае успешной авторизации</li>
<li>Если юзер уже авторизован - запустит координатор просмотра новостей</li>
</ol>
</li>
<li>AuthCoordinator  <ol type="1">
<li>Запустит процесс авторизации</li>
<li>Будет совершать переходы по всем требуемым шагам - например ввод логина/пароля, смс-кода, установки никнейма и т.п.</li>
<li>По итогу успешной авторизации вызовет переданный ему на вход completionHandler.</li>
</ol>
</li>
<li>NewsCoordinator  <ol type="1">
<li>Отвечает за показ списка новостей</li>
<li>Реализовывает переход в детали конкретной новости внутри этого же координатора</li>
<li>При переходе в настройки создаёт координатор настроек, с качестве completionHandler-а может передать ему логику обновления своего списка новостей. Если в настройках изменились параметры  <ul>
<li>обновляет список</li>
</ul>
</li>
</ol>
</li>
<li>SettingsCoordinator  <ol type="1">
<li>Отвечает за работу с экраном настроек</li>
<li>При завершении работы и применении настроек вызывает completion, чтобы новости обновились</li>
</ol>
</li>
</ol>
<p>Именно координаторы реализуют интерфейс EventListener-ов вьюмоделей, о которых будет чуть ниже. Так как вызов переходов завязан на бизнес-логику приложения, то инициатором этих переходов являются именно вьюмодели. Поэтому координаторы выполняют связующую роль между тем, что происходит в логике приложений и тем, как это должно отражаться пользователю.</p>
<p>Чтобы работать с координаторами было проще, используется базовый класс, от которого наследуются остальные. Добавим его к нашему проекту.</p>
<p>Создадим в ios-проекте папку src/Coordinators и в ней файлик BaseCoordinator. Для начала докинем туда пару протоколов:</p>
<pre><code language="language-swift" class="language-swift">protocol ChildCoordinable {

    var childCoordinators: [Coordinator] { get set }

    func addDependency(_ coordinator: Coordinator)

    func removeDependency(_ coordinator: Coordinator?)

}
</code></pre>
<p>ChildCoordinable - необходим для корректной работы с зависимостями от дочерних координаторов. Необходимо не забывать добавлять зависимости на новый координаторы, очищать зависимость на конкретный координатор и запоминать список тех координаторов, которые являются дочерними к текущему.</p>
<pre><code language="language-swift" class="language-swift">protocol Coordinator: class {

    var completionHandler: (() -&gt; Void)? { get set }

    

    func start()

}
</code></pre>
<p>Coordinator - сам протокол координатора. По сути он должен иметь ровно две вещи - completionHandler, который вызовется при завершении его логической зоны ответственности. И функцию start. При её вызове он начинает запускать свой флоу таким образом, каким считает нужным.</p>
<p>И далее сам класс базового координатора, который реализует оба этих протокола:</p>
<pre><code language="language-swift" class="language-swift">class BaseCoordinator: NSObject, Coordinator, ChildCoordinable, UINavigationControllerDelegate {

    var childCoordinators: [Coordinator] = []

    var completionHandler: (() -&gt; Void)?

    

    let window: UIWindow

    

    weak var navigationController: UINavigationController?

    

    init(window: UIWindow) {

        self.window = window

    }

    

    func start() {

        

    }

    

    func addDependency(_ coordinator: Coordinator) {

        for element in childCoordinators where element === coordinator {

            return

        }

        childCoordinators.append(coordinator)

    }

    

    func removeDependency(_ coordinator: Coordinator?) {

        guard

            childCoordinators.isEmpty == false,

            let coordinator = coordinator

        else { return }

        

        for (index, element) in childCoordinators.enumerated() where element === coordinator {

            

            childCoordinators.remove(at: index)

            break

            

        }

    }

    

    func currentViewController() -&gt; UIViewController? {

        return self.navigationController?.topViewController?.presentedViewController ?? self.navigationController?.topViewController ?? self.navigationController

    }

    

    func popBack() {

        self.navigationController?.popViewController(animated: true)

    }

}
</code></pre>
<p>Для инициализации необходим только window. Также можно указать NavigationController с предыдущего координатора, для сохранения общей навигации.</p>
<p>Добавление и удаление зависимостей нужны для корректной очистки связей и памяти при построении цепочек координаторов.</p>
<p>Также есть вспомогательные методы, которые позволяют получить текущий контроллер - currentViewController и совершить переход назад - popBack.</p>
<p>От проекта к проекту базовый координатор может изменяться, обеспечивая дополнительные нужды проекта.</p>
<p>Теперь, когда у нас есть базовый координатор, создадим на его основе стартовый координатор приложения. Создаём рядом с AppDelegate файл для него, называем AppCoordinator:</p>
<pre><code language="language-swift" class="language-swift">import Foundation

import UIKit

class AppCoordinator: BaseCoordinator {

    // MARK:** - Overrides**

    override func start() {

        let vc = UIViewController()

        vc.view.backgroundColor = UIColor.green

        self.window.rootViewController = vc

    }

}
</code></pre>
<p>Пусть он пока будет совсем простой, создающий контроллер зелёного цвета и делает его главным экраном window.</p>
<p>Теперь нам надо познакомить AddDelegate с его координатором. Идём в AppDelegate.swift</p>
<p>Добавим ему ссылку на координатор приложения:</p>
<p>private (set) var coordinator: AppCoordinator!</p>
<p>А в didFinishLaunchingWithOptions после создания SharedFactory добавим создание координатора и вызов старта:</p>
<pre><code language="language-swift" class="language-swift">self.coordinator = AppCoordinator(

            window: self.window!

        )

self.coordinator.start()
</code></pre>
<p>Готово. Собираем, запускаем и видим наш зелёный контроллер:</p>
<p>Теперь дальнейшая логика переходов зависит от текущего контроллера и действий юзера на нём. Но зелёным прямоугольником мир не спасёшь и юзера не авторизуешь. Поэтому пора переходить к созданию нашей первой фичи.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Создаём нативную фичу" duration="20">
        <p>Как правило фичи в нативном проекте соответствуют аналогичным фичам в мультиплатформенном проекте. Мы начнём с простого - с авторизации. Если открыть в AndroidStudio проект и зайти в папку mpp-library, то мы увидим в ней папку features - это и есть наши фичи. В ней уже даже есть auth. Сделаем для неё нативную реализацию.</p>
<p>Сначала наметим структуру папок в нашем проекте. Внутри src создадим папку Features, а в ней - Auth. Для авторизации нам понадобится контроллер и координатор. Чтобы всё не смешивалось в кучу (а в боевых проектах в фиче сильно больше файлов будет) сразу научимся группировать по папкам содержимое фичи. Заведём директории под контроллеры, координаторы и сами классы. Получится следующая структура:</p>
<p>Вёрстку мы ведём через xib-файлы. Обработчики действий и связи настраиваются через IBActions и IBOutlets. Кастомизация UI-элементов стилями конкретного проекта уже происходит кодом. Здесь мы не будем уходить глубоко в кастомизацию, поэтому контроллер у нас будет довольно простой - лейбл, пара полей для ввода логина и пароля и кнопка входа.</p>
<p>На вкус и цвет фломастеры бывают разные, можешь отверстать экран по-своему. Основные требования - Label-заголовок, два UITextField и одна кнопка UIButton. Что-то типа такого:</p>
<p>И класс у неё также пока очень простой:</p>
<pre><code language="language-swift" class="language-swift">import UIKit

class AuthViewController: UIViewController {

    // MARK:** - Outlets**

    @IBOutlet private var welcomeLabel: UILabel!

    @IBOutlet private var loginTextField: UITextField!

    @IBOutlet private var passwordTextField: UITextField!

    @IBOutlet private var loginButton: UIButton!

    

    // MARK:** - Actions**

    

    @IBAction func onLoginButtonAction(_ sender: UIButton) {

        // On button Action

    }

}

Далее создадим координатор:

class AuthCoordinator: BaseCoordinator {

    // MARK:** - Overrides**

    override func start() {

        let vc = AuthViewController()

        self.window.rootViewController = vc

    }

}
</code></pre>
<p>Он также несложный. Состоит пока из одного метода start, который помещает на window наш созданный AuthViewController.</p>
<p>И чтобы это всё работало изменяем координатор приложения. Теперь нам там нужно убрать тот тестовый зелёный экран и запустить флоу координатора авторизации:</p>
<pre><code language="language-swift" class="language-swift">class AppCoordinator: BaseCoordinator {

    // MARK:** - Overrides**

    override func start() {

        routeToAuth()

    }

    

    private func routeToAuth() {

        

        // 1. Создаём координатор авторизации

        

        let authCoordinator = AuthCoordinator(window: self.window)

        

        // 2. Обязательно указываем в completionHandler удаление зависимости.

        // Также добавляем сразу заготовку под будущий переход к новостям при успешной авторизации

        authCoordinator.completionHandler = { [weak self] in

            self?.removeDependency(authCoordinator)

            self?.routeToNewsList()

        }

        

        // 3. Добавляем новый координатор в зависимость к текущему

        addDependency(authCoordinator)

        

        // 4. Вызываем у него старт

        authCoordinator.start()

    }

    private func routeToNewsList() {

        // Здесь будет переход к новостям

    }

}

</code></pre>
<p>Собираем, запускаем и видим уже не тот недохромакей, а контроллер авторизации, который только что сверстали. Комментариями к коду подписаны основные шаги в создании нового координатора. Важным моментом является удаление зависимости в completion-блоке создаваемого координатора, чтобы не плодились утечки памяти.</p>
<p>Также полезно будет указать сразу заглушку для метода перехода к новостям. Пусть он пока и пустой, зато сразу получаем более общую картину, где какие вызовы будут в будущем.</p>
<p>Окей. Мы создали контроллер, создали координатор. Даже перешли на экран авторизации. Но как будет реализовываться логика? Где брать вьюмодель? Как она узнает, что юзер что-то ввёл? Как координатор поймёт, что ему нужно вызывать completion и переходить к новостям, ведь контроллер, который мы создали, даже не знает о том, что какой-то там координатор существует?</p>
<p>Чтобы понять, как это работает перейдём к созданию вьюмодели и передаче её контроллеру.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Дружим ViewController и ViewModel" duration="5">
        <p>// Описать создание VM через фабрику, добавить базовый MVVM контроллер, допилить AuthController, сделать пустой биндинг и перейти к описанию</p>


      </google-codelab-step>
    
      <google-codelab-step label="Принцип связи общей и нативной частей" duration="5">
        <p>// Пояснить, что есть что и где находится в общих чертах, дальше перейти к деталям</p>


      </google-codelab-step>
    
      <google-codelab-step label="Обработка действий пользователя и передача данных от натива к общей части" duration="5">
        <p>// Заводим филды во вьюмодели, публичный метод для обработчика кнопки с принтом в консоль, показываем, как биндиться к филдам, биндим доступность кнопки, биндим текст лейбла к лайвдате</p>


      </google-codelab-step>
    
      <google-codelab-step label="Реализация логики и передача событий и команд от общей части к нативной" duration="5">
        <p>// Дополняем EventListener для VM авторизации, в ней роут на новости и showError</p>
<p>ПОКАЗАТЬ ЧТО СБОРКА ЛОМАЕТСЯ, объяснить, как влияют правки общие на соседнюю платформу. Замокать без репозитория на уровне VM проверку логина/пароля.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Локализация и ресурсы" duration="5">
        <p>// Рассказать про моко-ресурсы, завести табличку, добавить строк, добавить интерфейс строк в VM, пробросить при реализации, изменить текста ошибок на StringDesc локализованный.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Сохранение в локальное хранилище." duration="5">
        <p>// Добавить логику запоминания токена в локальном хранилище. Показать, как с сеттингсами работать.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Построение экранов" duration="5">
        <p>// Раздел для описания разных подходов к вёрстке экранов</p>
<h2 is-upgraded>Нативная вёрстка</h2>
<p>// Сослаться на авторизацию, объяснить про вёрстку на чистом нативе с биндингами</p>
<h2 is-upgraded>На основе юнитов</h2>
<p>// Рассказать, что такое юниты, переходить к вёрстке списка новостей, создавать фабрику юнитов, описать, что стоит, а что не стоит кидать в них, когда нужны id, что такое диффабл датасурс, почему текстовые поля и юниты - не всегда супер хорошо</p>


      </google-codelab-step>
    
      <google-codelab-step label="Работа с сервером и запросами" duration="5">
        <h2 is-upgraded>Как генерируются API?</h2>
<p>Показываем генерацию по спекам, куда попадают файлы</p>
<h2 is-upgraded>Как создать свою, если нужен запрос, а нет swagger?</h2>
<p>Показываем, как создать свой Api-класс</p>
<h2 is-upgraded>Как вьюмодель ходит на сервер?</h2>
<p>Рассказать про интерфейс репозитория, который есть у фичи. Создать его для авторизации, реализовать, добавить в создании доменной фабрики</p>
<h2 is-upgraded>Как правильно мокать, если не готов сервер?</h2>
<p>Показать, как правильно мокать на уровне репозитория и почему предыдущее решение с моком на вьюмодели неоптимальное. Докинуть примеров.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Обработка ошибок" duration="5">
        <p>// моко-еррорс</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
